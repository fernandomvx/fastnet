/** 
@file  matnetdata.h
@brief MatNetData class declaration/definition file.
*/

#ifndef MATNETDATA_H
#define MATNETDATA_H

#include <list>
#include <vector>
#include <mex.h>

#include "fastnet/netdata/netdata.h"
#include "fastnet/defines.h"
#include "fastnet/events/mxhandler.h"

using namespace std;


namespace FastNet
{
  /** 
  @brief    Derived class for neural network's data stored into memory (improved speed) and interfaced with matlab.
  @author    Rodrigo Coura Torres (torres@lps.ufrj.br)
  @version  1.0
  @date    03/06/2005

  This class implements the virtual methods of NetData for managing the data generated during network
  execution. It works in memory as much as possible, in order to improve speed. This class is used
  in order to provide the interface with the Matlab environment.
  */
  class MatNetData : public NetData
  {
    private:
      //Class attributes.

      /// Structure that holds the data generated during training.
      /**
       This struct holds the data generated during training, like epoch and error
       information. This struct is to be used with the linked list that will hold
       these values.
      */
      typedef struct
      {
        /// The epoch in which the training is.
        REAL epoch;
        
        /// The training error obtained in the epoch.
        REAL trnError;
        
        /// The testing error obtained in the epoch.
        REAL tstError;
      } TrainData;
      

      /// References the network structure with the neural network configuration.
      /**
       This attribute points to the matlab variable that holds the 
       neural network configuration values.
      */
      const mxArray *mNet;
    
      
      // Stores the traning data history passed to the class.
      /**
       When the user wants to store the data generated during training (epoch and error
       information), these values will be placed in struct TrainData and will be added
       to this linked list.
      */
      list<TrainData> trnList;

      /// Stores the output generated by the network.
      /**
       This linked list stores the output generated by the neural network.
      */
      list<REAL*> outList;
      
      //Stores the intermediate weight values results during training.
      /**
       Each time the weights (during training) must be saved, those are actually saved
       in this attribute, in order to improve speed, since the are stored into RAM.
       **/
      REAL ***weight;

      //Stores the intermediate bias values results during training.
      /**
       Each time the biases (during training) must be saved, those are actually saved
       in this attribute, in order to improve speed, since the are stored into RAM.
       **/
      REAL **bias;

    public:

      /// Class constructor.
      /**
       This constructor receives the network structure from where the initial weights and biases values will be read.
       It also allocates memory for storing the intermediate weights and biases values.
       @param[in] nodesDist The vector specifying the number of nodes in each layer (including the input layer).
       @param[in] matNet A pointer to the Matlab structure holding the network structure information.
       @throw bad_alloc in case of error allocating memory.
      */
      MatNetData(vector<unsigned> &nodesDist, const mxArray *matNet) : NetData(nodesDist)
      {
        const unsigned size = nLayers - 1;
        mNet = matNet;
        
        //Allocating the space needed to temporally store the weights and biases values
        try
        {
          //Allocating the bias matrix.
          bias = new REAL* [size];
          //Initiallizing with NULL in case of an future error on allocating memory.
          for (unsigned i=0; i<size; i++) bias[i] = NULL;
          //Allocating the matrix's collumns.
          for (unsigned i=0; i<size; i++) bias[i] = new REAL [nNodes[i+1]];

          //Allocating the weight matrix.
          weight = new REAL** [size];
          for (unsigned i=0; i<size; i++) weight[i] = NULL;
          for (unsigned i=0; i<size; i++)
          {
            weight[i] = new REAL* [nNodes[i+1]];
            for (unsigned j=0; j<nNodes[i+1]; j++) weight[i][j] = NULL;
            for (unsigned j=0; j<nNodes[i+1]; j++) weight[i][j] = new REAL [nNodes[i]];
          }
        }
        catch(bad_alloc xa)
        {
          throw;
        }
      }


      /// Class destructor.
      /**
       This destructor releases all memory used by this class, that includes
       the memory used for each network's output stored in the linked list
       and that used to store the intermediate weights and biases values.
      */
      ~MatNetData()
      {
        const unsigned size = nLayers - 1;
        
        //Releasing the outputs values.
        list<REAL*>::iterator itr = outList.begin();
        while (itr != outList.end()) delete [] *itr++;
        
        // Deallocating the bias matrix.
        if (bias)
        {
          for (unsigned i=0; i<(nLayers-1); i++)
          {
            if (bias[i]) delete [] bias[i];
          }
          delete [] bias;
          bias = NULL;
        }
          
        // Deallocating the weight matrix.      
        if (weight)
        {
          for (unsigned i=0; i<(nLayers-1); i++)
          {
            if (weight[i])
            {
              for (unsigned j=0; j<nNodes[i+1]; j++)
              {
                if (weight[i][j]) delete [] weight[i][j];
              }
              delete [] weight[i];
            }
          }
          delete [] weight;
          weight = NULL;
        }      
      }
      
      
      /// Writes the weights in a memory buffer.
      /**
       To improve speed during training, where the weights values change a lot,
       this function stores these values in a memory buffer, without loss
       of performance. But this function DOES NOT stores those values in a non-volatile
       environment, so these values are lost after the training is finished. In order to
       actually save the weights and biases for posterior use in matlab, you must call, after the training is
       done, the flushWeights method.
       @param[in] w the weight matrix to be saved.
       @param[in] b the biases matrix to be saved.
       @see FastNet::NetData#writeWeights for information on how the weight and bias matrixes must be organized.
       @see FastNet::MatNetData#flushWeights for information on how the save 
       the weights and biases for posterior use in matlab.
      */
      void writeWeights(REAL ***w, REAL **b)
      {
        for (unsigned i=0; i<(nLayers-1); i++)
        {
          memcpy(bias[i], b[i], nNodes[(i+1)]*sizeof(REAL));
          
          for (unsigned j=0; j<nNodes[(i+1)]; j++)
          {
            memcpy(weight[i][j], w[i][j], nNodes[i]*sizeof(REAL));
          }
        }
      }


      /// Writes the training information of a network in a linked list.
      /**
       This method writes in a linked list in memory the information generated
       by the network during training, for improved speed. To actually stores this
       values for posterior use in matlab, you must call, at the end of the training process,
       the flushErrors method. 
       @param[in] epoch The epoch number.
       @param[in] trnError The training error obtained in that epoch.
        @param[in] tstError The testing error obtained in that epoch.
        @see FastNet::MatNetData#flushErrors for information on how the save 
        the error information for posterior use in matlab.
      */
      void writeErrors(unsigned epoch, REAL trnError, REAL tstError)
      {
        TrainData trainData;
        trainData.epoch = (REAL) epoch;
        trainData.trnError = trnError;
        trainData.tstError = tstError;
        trnList.push_back(trainData);
      }


      /// Writes the network's output to a linked list in memory.
      /**
       This method writes the output generated by the network (during training/testing/production)
       in a linked list in memory, in order to maximize speed. The output passed
       in copyed to another vector (dynamically allocated) and then added to the linked list.
       Since this output values are stored into memory, they are lost after the end
       of this class usage. To actually stores them for later use in matlab, you must
       call the flushOutputs function.
       @param[in] out A vector containing the output generated by the neural network.
       @throw bad_alloc in case of error allocating memory.
       @see FastNet::MatNetData#flushOutputs for information on how the save 
        the outputs for posterior use in matlab.
      */
      void writeOutput(const REAL *out)
      {
        const unsigned outSize = nNodes[nLayers-1];
        
        try
        {
          REAL *aux = new REAL [outSize];
          memcpy(aux, out, outSize*sizeof(REAL));
          outList.push_back(aux);
        }
        catch(bad_alloc xa)
        {
          throw;
        }
      }


      /// Flush weights from memory to an Matlab variable.
      /**
       Since this class, in order to optimize speed, saves the
       weights and bias values into memory, at the end, if the user wants
       to save the final values, this method must be called. It will
       save the weights and biases values stored in the memory buffer in a matlab variable.
       So, this method can only be used after the writeWeights has been called at least once.
       @param[out] outNet The matlab network structure to where the weights and biases will be saved to.
      */
      void flushWeights(mxArray *outNet)
      {
        // It must be of double tye, since the matlab net tructure holds its info with
        //double precision.      
        MxArrayHandler<double> iw, ib;
        mxArray *lw;
        mxArray *lb;
        
        //Getting the bias cells vector.
        lb = mxGetField(outNet, 0, "b");
        
        //Processing first the input layer.
        iw = mxGetCell(mxGetField(outNet, 0, "IW"), 0);
        ib = mxGetCell(lb, 0);
        
        for (unsigned i=0; i<nNodes[1]; i++)
        {
          for (unsigned j=0; j<nNodes[0]; j++) iw(i,j) = static_cast<double>(weight[0][i][j]);
          ib(i) = static_cast<double>(bias[0][i]);
        }
        
        //Processing the other layers.
        //Getting the weights cell matrix.
        lw = mxGetField(outNet, 0, "LW");
        
        for (unsigned i=1; i<(nLayers-1); i++)
        {
          iw = mxGetCell(lw, iw.getPos(i,(i-1), mxGetM(lw)));
          ib = mxGetCell(lb, i);
              
          for (unsigned j=0; j<nNodes[(i+1)]; j++)
          {
            for (unsigned k=0; k<nNodes[i]; k++) iw(j,k) = static_cast<double>(weight[i][j][k]);
            ib(j) = static_cast<double>(bias[i][j]);
          }
        }
      }


      /// Flush errors from memory to an Matlab structure
      /**
       Since this class, in order to optimize speed, saves the
       training information (epochs and errors) values into memory, at the end, if the user wants
       to save the final values, this method must be called. It will
       save these values stored in the linked list in Matlab vectors.
       So, this method can only be used after the writeErrors has been called at least once.
       @param[out] epoch A vector containing the epochs values.
       @param[out] trnError A vector containing the training error obtained in each epoch.
       @param[out] tstErrorA vector containing the testing error obtained in each epoch.
      */
      void flushErrors(mxArray *&epoch, mxArray *&trnError, mxArray *&tstError) const
      {
        unsigned k = 0;
        TrainData aux;
        const unsigned size = trnList.size();
        list<TrainData>::const_iterator itr = trnList.begin();
        
        epoch = mxCreateNumericMatrix(1, size, REAL_TYPE, mxREAL);
        trnError = mxCreateNumericMatrix(1, size, REAL_TYPE, mxREAL);
        tstError = mxCreateNumericMatrix(1, size, REAL_TYPE, mxREAL);

        REAL *ep = static_cast<REAL*>(mxGetData(epoch));
        REAL *trn = static_cast<REAL*>(mxGetData(trnError));
        REAL *tst = static_cast<REAL*>(mxGetData(tstError));
        
        while (itr != trnList.end())
        {
          aux = *itr++;
          ep[k] = aux.epoch;
          trn[k] = aux.trnError;
          tst[k] = aux.tstError;
          k++;
        }
      }


      /// Flush outputs from memory to an Matlab variable.
      /**
       Since this class, in order to optimize speed, saves the
       network's outputs into memory, at the end, if the user wants
       to save these outputs, this method must be called. It will
       save the output values stored in the linked list in an Matlab variable.
       So, this method can only be used after the writeOutput has been called at least once.
       @return An Matlab matrix containing the outputs, where each column is a generated output.
      */
      mxArray *flushOutputs() const
      {
        unsigned k = 0;
        const unsigned outSize = nNodes[nLayers-1];
        REAL *out;
        mxArray *ret = mxCreateNumericMatrix(outSize, outList.size(), REAL_TYPE, mxREAL);
        list<REAL*>::const_iterator itr = outList.begin();
        MxArrayHandler<REAL> ptr = ret;

        while (itr != outList.end())
        {
          out = *itr++;
          for (unsigned i=0; i<outSize; i++) ptr(i,k) = out[i];
          k++;
        }

        return ret;
      }
  };
}

#endif
