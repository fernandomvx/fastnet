/** 
@file  memnetdata.h
@brief MemNetData class declaration file.
*/


#ifndef MEMNETDATA_H
#define MEMNETDATA_H


#include <fstream>
#include <list>
#include <vector>
#include <cstring>

#include "TrigRingerTools/fastnet/netdata.h"
#include "TrigRingerTools/fastnet/defines.h"

using namespace std;


namespace FastNet
{
	/** 
	@brief		Derived class for neural network's data stored into memory (improved speed).
	@author		Rodrigo Coura Torres (torres@lps.ufrj.br)
	@version	1.0
	@date		14/11/2004

	This class implements the virtual methods of NetData for managing the data generated during network
	execution. It works in memory as much as possible, in order to improve speed.
	*/
	class MemNetData : public NetData
	{
		private:
			//Class attributes.

			/// Structure that holds the data generated during training.
			/**
			 This struct holds the data generated during training, like epoch and error
			 information. This struct is to be used with the linked list that will hold
			 these values.
			*/
			typedef struct
			{
				/// The epoch in which the training is.
				REAL epoch;
				
				/// The training error obtained in the epoch.
				REAL trnError;
				
				/// The testing error obtained in the epoch.
				REAL tstError;
			} TrainData;
			

			/// Holds the name of the file where the weights will be read from.
			/**
			 This attribute will be used only if the class user specifies a file name
			 where the initial weights and biases values will be read from. If a file name
			 were not specified, this attribute must be NULL, since the class will check
			 the existence of that input file by verifying if this attribute is different from NULL.
			*/
			string inWeightFile;
			
			// Stores the traning data history passed to the class.
			/**
			 When the user wants to store the data generated during training (epoch and error
			 information), these values will be placed in struct TrainData and will be added
			 to this linked list.
			*/
			list<TrainData> trnList;

			/// Stores the output generated by the network.
			/**
			 This linked list stores the output generated by the neural network.
			*/
			list<REAL*> outList;

			/// A pointer to a memory region where the weights and biases will be saved.
			/**
			 In order to improve speed, this class stores, during training, the weights and
			 biases values in a memory buffer. This pointer points to the begining of this memory
			 region.
			*/
			REAL *wStore;

			// Holds the size (in words) of the space need to store the weights and biases values.
			/**
			 Since the space needed to store the weights and biases values is unknown until
			 runtime, this variable stores the amount of space (in words) needed to store
			 these values.
			*/
			int totSize;


		public:

			/// Class constructor.
			/**
			 This constructor calculates the amount of space needed to store 
			 the weights and biases values. After that, its allocates the amount of memory needed
			 This constructor also verifies if the calling function specifies
			 an input file from where the initial weights and biases values will be read.
			 @param[in] nodesDist The vector specifying the number of nodes in each layer (including the input layer).
			 @param[in] inWeightFileName Specifies the name of the file that contains the weights and biases
			 values. If no file will be used to initialize these values, this parameter must be NULL.
			 @throw bad_alloc in case of memory allocation error.
			*/
			MemNetData(vector<int> &nodesDist, char *inWeightFileName = NULL) : NetData(nodesDist)
			{
				totSize = 0;
				wStore = NULL;
				
				try
				{
					if (inWeightFileName) inWeightFile = inWeightFileName; 

					for (int i=1; i<nLayers; i++)
					{
						totSize += ( (nNodes[i]*nNodes[(i-1)]) + nNodes[i]);
					}
	
					wStore = new REAL [totSize];
				}
				catch(bad_alloc xa)
				{
					throw;
				}
			}


			/// Class destructor.
			/**
			 This destructor releases all memory used by this class, that includes
			 the memory used to store the weights and biases values and the memory
			 used for each network's output stored in the linked list.
			*/
			~MemNetData()
			{
				if (wStore) delete [] wStore;
				list<REAL*>::iterator itr = outList.begin();
				while (itr != outList.end()) delete [] *itr++;
			}


			/// Writes the weights in a memory buffer.
			/**
			 To improve speed during training, where the weights values change a lot,
			 this function stores these values in a memory buffer. This memory buffer
			 is a contiguos memory region, in order to simplify the code, without loss
			 of performance.
			 @param[in] w the weight matrix to be saved.
			 @param[in] b the biases matrix to be saved.
			 @see FastNet::NetData#writeWeights for information on how the weight and bias matrixes must be organized.
			*/
			void writeWeights(REAL ***w, REAL **b)
			{
				REAL *ptr = wStore;

				for (int i=0; i<(nLayers-1); i++)
				{
					for (int j=0; j<nNodes[(i+1)]; j++)
					{
						*ptr++ = b[i][j];
						memcpy(ptr, w[i][j], (nNodes[i]*sizeof(REAL)));
						ptr += nNodes[i];
					}
				}
			}


			/// Reads the initial weights and biases from a file.
			/**
			 This method reads the weights and biases values from the file
			 passed to this class by its constructor.
			 @param[in] w A pointer to where the weight values will be saved.
			 @param[in] b A pointer to where the bias values will be saved.
			 @throw OPEN_FILE_ERROR if an error occur while trying to open the input file or if none was specified in class constructor (NULL value).
			 @see FastNet::NetData#readWeights for information on how the weight and bias matrixes must be organized.
			*/
			void readWeights(REAL ***w, REAL **b)
			{
				ifstream inWeight;

				if (inWeightFile.size())
				{
					inWeight.open(inWeightFile.c_str(), ios::binary);
					
					if (!inWeight)
					{
						throw "Impossible to open the input weight file!";
					}
				}
				else throw "Input weight file not specified!";

				for (int i=0; i<(nLayers-1); i++)
				{
					for (int j=0; j<nNodes[(i+1)]; j++)
					{
						inWeight.read((char*) &b[i][j], sizeof(REAL));
						inWeight.read((char*) w[i][j], (nNodes[i]*sizeof(REAL)));
					}
				}
			}


			/// Writes the training information of a network in a linked list.
			/**
			 This method writes in a linked list in memory the information generated
			 by the network during training, for improved speed.
			 @param[in] epoch The epoch number.
			 @param[in] trnError The training error obtained in that epoch.
 			 @param[in] tstError The testing error obtained in that epoch.
			*/
			void writeErrors(int epoch, REAL trnError, REAL tstError)
			{
				TrainData trainData;
				trainData.epoch = (REAL) epoch;
				trainData.trnError = trnError;
				trainData.tstError = tstError;
				trnList.push_back(trainData);
			}


			/// Writes the network's output to a linked list in memory.
			/**
			 This method writes the output generated by the network (during training/testing/production)
			 in a linked list in memory, in order to maximize speed. The output passed
			 in copyed to another vector (dynamically allocated) and then added to the linked list.
			 @param[in] out A vector containing the output generated by the neural network.
			 @throw bad_alloc in case of error allocating memory.
			*/
			void writeOutput(REAL *out)
			{
				int outSize = nNodes[nLayers-1];
				
				try
				{
					REAL *aux = new REAL [outSize];
					memcpy(aux, out, outSize*sizeof(REAL));
					outList.push_back(aux);
				}
				catch(bad_alloc xa)
				{
					throw;
				}
			}


			/// Flush weights from memory to a file.
			/**
			 Since this class, in order to optimize speed, saves the
			 weights and bias values in memory, at the end, if the user wants
			 to save the final values, this method must be called. It will
			 save the weights and biases values stored in the memory buffer in a binary disk file (REAL type).
			 So, this method can only be used after the writeWeights has been called at least once.
			 @param fileName the name of the file where the weights and biases will be saved to.
			 @throw OPEN_FILE_ERROR if an error occur during file opening.
			*/
			void flushWeights(char *fileName)
			{
				ofstream out(fileName, ios::binary);
				if (!out) throw "Impossible to write the weights data!";
				out.write((char*) wStore, (totSize*sizeof(REAL)));
				out.close();
			}


			/// Flush errors from memory to a file.
			/**
			 Since this class, in order to optimize speed, saves the
			 training information (epochs and errors) values in memory, at the end, if the user wants
			 to save the final values, this method must be called. It will
			 save these values stored in the linked list in a binary disk file.
			 So, this method can only be used after the writeErrors has been called at least once.
			 @param fileName the name of the file where the training information will be saved to.
			 @throw OPEN_FILE_ERROR if an error occur during file opening.
			*/
			void flushErrors(char *fileName)
			{
				ofstream out(fileName, ios::binary);
				if (!out) throw "Impossible to write the error data!";

				TrainData aux;
				list<TrainData>::iterator itr = trnList.begin();
				while (itr != trnList.end())
				{
					aux = *itr++;
					out.write((char*) &aux, sizeof(TrainData));
				}

				out.close();
			}


			/// Flush outputs from memory to a file.
			/**
			 Since this class, in order to optimize speed, saves the
			 network's outputs in memory, at the end, if the user wants
			 to save these outputs, this method must be called. It will
			 save the output values stored in the linked list in a binary disk file (REAL type).
			 So, this method can only be used after the writeOutput has been called at least once.
			 @param fileName the name of the file where the outputs will be saved to.
			 @throw OPEN_FILE_ERROR if an error occur during file opening.
			*/
			void flushOutputs(char *fileName)
			{
				ofstream out(fileName, ios::binary);
				if (!out) throw "Impossible to write the outputs data!";

				list<REAL*>::iterator itr = outList.begin();

				while (itr != outList.end())
				{
					out.write((char*) *itr++, nNodes[(nLayers-1)]*sizeof(REAL));
				}

				out.close();
			}
	};
}

#endif
